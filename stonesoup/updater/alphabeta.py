# -*- coding: utf-8 -*-


import numpy as np

from stonesoup.base import Property
from stonesoup.updater import Updater
from stonesoup.types.update import Update



class AlphaBetaUpdater(Updater):
    r"""Conceptually, the $\alpha-\beta$ filter is similar to its Kalman cousins in that it
    operates recursively over predict and update steps. It assumes that a state is decomposable
    into position $p$ and velocity $v$ components. Assuming that the interval from
    $k-1 \rightarrow k$ is $\Delta T$, and assuming that, at $k$, we can gain a measurement of the
    position, $p^z_k$. The recursion proceeds as:

    * Predict

        $p_{k|k-1} = p_{k-1} + \Delta T v_{k-1}$

        $v_{k|k-1} = v_{k-1}$

    * Update

        Innovation, $s_k = p^z_k - p_{k|k-1}$

        $p_k = p_{k|k-1} + \alpha s_k$

        $v_k = v_{k|k-1} + \frac{\beta}{\Delta T} s_k$

    Thw $\alpha$ and $\beta$ parameters which give the filter its name are small, $0 < \alpha < 1$
    and $0 < \beta \leq 2$. Colloquially, the larger the values of the parameters, the more
    influence the measurements have over the transition model; $\beta$ is usually much smaller than
    $\alpha$.

    As the prediction is just the application of a constant velocity model, there is no
    $\alpha-\beta$ predictor provided in Stone Soup. It is assumed that the predictions provided in
    the hypothesis have been generated by a constant velocity model.


    """


    alpha: float = Property(doc="The alpha parameter. Controls the weight given to the measurements "
                                "over the transition model.")
    beta: float = Property(doc="The beta parameter. Controls the amount of variation allowed in the "
                               "velocity component.")

    pmap: np.ndarray = Property(default=np.array([0]), doc="Binary map of the position elements in"
                                                           "the state vector")
    vmap: np.ndarray = Property(default=np.array([1]), doc="Binary map of the velocity elements in"
                                                           "the state vector")


    def predict_measurement(self, prediction, **kwargs):
        """Return the predicted measurement

        Parameters
        ----------
        prediction : :class:`~.StatePrediction`
            The state prediction

        Returns
        -------
         : :class:`~.StateVector`
            The predicted measurement
        """
        return prediction.state_vector[self.pmap]

    def update(self, hypothesis, time_interval, **kwargs):
        """Calculate the inferred state following update

        Parameters
        ----------
        hypothesis : :class:`~.Hypothesis`
            A hypothesis associates a measurement with a prediction
        time_interval : :class:`~.timedelta`
            The time interval over which the prediction has been made.

        Returns
        -------
         : :class:`~.StateUpdate`
            The updated state
        """
        out_statevector = hypothesis.prediction.state_vector.copy()
        pred_meas = self.predict_measurement(hypothesis.prediction)

        innovation = hypothesis.measurement.state_vector - pred_meas
        out_statevector[self.pmap] = pred_meas + self.alpha * innovation
        out_statevector[self.vmap] = hypothesis.prediction.state_vector[self.vmap] + (
                    self.beta / time_interval.total_seconds()) * innovation

        return Update.from_state(hypothesis.prediction, out_statevector, timestamp=hypothesis.measurement.timestamp,
                                 hypothesis=hypothesis)

